###chapter 7
####访问权限控制
####
+ 7.1继承
	* extends关键字，子类会自动得到基类中所有的属性和方法，父类中private属性，在子类中只能通过get、set方法访问
	* 对于继承获得的方法，如果子类没有覆盖，直接通过子类对象名就可以访问，如果已经覆盖，则只能在类定义属性和方法中通过super.调用对应覆盖了的父类方法
	* 每个类除非已经明确指出继承了某个类，否则都默认继承于Object
+ 7.2.1 初始化基类
	* java会自动在子类构造器中插入对基类构造器的调用
	* 子类默认的构造器也是这样
	* 保证子类在可以访问父类之前已经完成父类的基本初始化
+ 7.2.2 带参数的构造器
	* 如果在父类中自己定义了带参数的和默认构造器不同的构造器
	* 子类在构造器中第一件事就是用super关键字显示的调用
	* 如果按照默认调用就找不到对应父类构造器
+ 7.3.1 确保正确清理
	* 首先执行类的所有清理动作，然后调用父类的清理动作
+ 7.3.2 继承与组合
	* is-a（是一个）的关系用继承
	* has-a（有一个）的关系用组合
+ 7.4.1 向上转型
	* 导出类转换为基类，较专用类型转换为较通用类型，安全转型，只有方法丢失，没有获取
+ 7.4.2 组合与继承的选择
	* 是否需要从新类向基类进行向上转型，如果必须，就用继承
+ 7.8.1 final数据
	* 一个既是static又是final的域只占据一段不能改变的存贮空间 命名大写
	* 对于基本类型，final使数值 不变
	* 对于引用，final使引用不变，一旦引用初始化指向一个对象，就无法再把他指向另一个对象，但是被指向的对象自身是可以被修改的。
	* 空白final域，申明时未赋值，使用前初始化，在构造器中初始化，根据不同对象可以有不同值，对于static的就只有一份值了

+ 7.8.2 final方法
	* 明确禁止方法被覆盖，在子类中
	* private 方法隐式的指定为final
	* private 方法只能说明只是属于指定类私有方法
	* private 属性和方法一种是子类中没有被继承，因为属于父类私有。一种是被继承，但是属于父类私有，在子类中被隐藏了，就是在子类中出现相同的方法也是一个属于子类的其他的方法

+ 7.8.3 final类
	* final 类 不能被继承 方法隐式加了final关键字，但属性没有，表示方法不能被覆盖，因为父类不能被继承