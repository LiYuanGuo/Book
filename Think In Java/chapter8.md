###chapter 8
####多态
####
+ 8.1多态
	* 消除类型之间的耦合关系
	* 将未变的事物与改变的事物分离开来
	* 后期绑定：在运行时根据对象的类型进行绑定，也叫动态绑定、运行时绑定
	* java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定

+ 8.2.1缺陷：‘覆盖’私有方法
	*父类private方法对子类屏蔽，如果子类存在同名public方法，当把子类引用传给父类，调用该方法，调用的是父类私有方法，因为私有方法不能被子类覆盖，子类同名方法是一个新方法，调用的要是被子类覆盖的方法，否则就调用父类中该方法
+ 8.2.2 缺陷：域和静态方法
	* 域不能多态
	* 静态方法是与类关联的只有一份，没有多态
	* 只有一半方法才有多态
+ 8.3.1 构造器和多态
	* 构造器并不具有多态，它们实际上是static方法，隐式声明为static方法。
	* 基类构造器总是在子类构造器中首先被默认调用。
	
+ 8.3.2 复杂对象调用构造器构造过程
	* 1 调用基类构造器
	* 2 按声明顺序初始化成员变量
	* 3 调用导出类构造器主体
+ 8.3.3 继承与清理
	* 先清理子类，然后清理基类（清理顺序和初始化顺序相反），因为清理子类时可能会调用基类方法
	* 对于字段初始化顺序和声明顺序相同，所以清理顺序和声明顺序相反
	* 对于共享对象的清理用引用计数
+ 8.3.4 构造器内部的多态方法调用
	* 基类构造器中调用多态方法，在子类创建对象时调用父类构造器时会调用子类覆盖的方法，然而此时子类属性还没有被初始化，幸好在创建对象前，将分配给对象的存储空间会被初始化成二进制的零，是引用的对应的是null
	* 创建对象初始化实际过程：
	* 1 在其他任何事物发生前，将分配给对象的存储空间初始化为二进制的零
	* 2 先调用父类构造器
	* 3 按声明的顺序初始化子类
	* 4 调用导出类构造器主体
+ 8.4 协变返回类型
	* java SE5中添加了协变返回类型，即导出类中的覆盖方法可以返回基类被覆盖方法的返回类型的导出类型。
	* 这样返回的类型更具体
+ 8.5 转型
	* 向上转型时安全的，不会多于子类的接口数
	* 向下转型不安全，在不知道明确子类类型的情况下贸然转型到某一子类类型，你调用的方法有可能就没得