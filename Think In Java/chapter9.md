###chapter 9
####接口
####
+ 9.1抽象类和抽象方法
	* 抽象方法：仅有声明没有方法体
	* 抽象类：包括一个或者多个抽象方法的类，必须得限定为抽象类（abstract）
	* 抽象类：也可以定义没有任何抽象方法的类，这样可以阻止产生这个类的任何对象
+ 9.2 接口
	* 接口中也可以包含域，隐式的是static,final（final在定义时就要求被初始化，否则编译出错）
	* 当要实现一个接口时，在接口中定义的方法必须被定义为public的，否则如果为包访问权限，访问权限太低，Java编译器不允许
	* 接口中的方法默认为public，但是对于接口定义 默认为包访问权限
	* 接口里面的方法不能定义为private和protected 否则编译器要报错，权限太低
	* 接口继承了java类：一在.class文件中的super_class标志中可以看到，另外《深入java虚拟机》第二版以及《The Java Virtual Machine Specification》second edition中有说到。二通过代码也可以验证，你把一个对象赋值给一个接口的引用，是可以调用Object中的wait，notify等方法的
+ 9.3 完全解耦
	* 接口能被任何类实现，解耦】
	* 策略设计模式：对于方法参数中同一参数，传入不同参数，对其他数据操作拥有不同的行为
	* 如方法process(Processor p,Object s)传入不同的子类p将对s产生不同的操作，p对象就是一个策略，将这个策略作用于s
	* 适配器模式：（为了满足用户的需要）一个类装配（实现）一个或多个接口的功能和装配（继承）多个类的方法，然后把这个类提供给其他用户用，这个类就是一个适配器
+ 9.4.1 Java中的多重继承
	* 一个类只能继承一个类
	* 一个类能实现多个接口以逗号隔开
	* extends关键字要在implements关键前，否则编译器报错
+ 9.5.2 使用接口的理由
	* 为了能够向上转型为基类，降低耦合
	* 防止客户端创建该类型对象
+ 9.5.3 接口和抽象类选择
	* 优先接口
+ 9.5 通过继承来扩展接口
	* 一个接口可以继承extends多个接口，用逗号隔开
	* 接口不能实现implements接口
+ 9.5.1 组合接口时的方法名字的冲突
	* 接口继承不同接口，在不同接口中有相同名字相同参数列表（参数个数、类型、所有参数不是同一类型时参数顺序还要一样）但返回不同类型的方法时，此时继承会报错
	* 或者一个类继承一个类和实现一个接口时，类和接口有相同名字相同参数列表（参数个数、类型、所有参数不是同一类型时参数顺序还要一样）但返回不同类型的方法时，此时继承会报错
	* 因为同一个类中不能存在同一个方法（同一个类中相同方法名和相同参数列表（个数和类型、所有参数不是同一类型时参数顺序还要一样）决定是同一个方法），返回类型不能用来决定方法相同（同一类中）
	* 返回类型不能用来区分方法重载，因为调用时直接写成方法名加参数没考虑返回类型，无法区分该调用哪个方法
+ 9.6 适配接口
	* 适配器模式：（为了满足用户的需要）一个类装配（实现）一个或多个接口的功能和装配（继承）多个类的方法，然后把这个类提供给其他用户用，这个类就是一个适配器
+ 9.7 接口中的域
	* 接口中的域默认是public访问权限，以及static（只有一份），final常量（定义时就要初始化，之后不能改变）
+ 9.8 在类中或者接口中嵌套接口
	* 在类中嵌套接口，接口可以为private
	* 在接口中嵌套接口，被嵌套的接口不能为private，自动是public
	* 调用方法 类名.接口名，或者接口名.接口名
	* 类实现接口时并不需要实现其嵌套的接口，要实现时用内部类实现嵌套接口
	
+ 9.9 总结
	* 恰当的原则应该是优先选择类而不是接口，从类开始分析，如果真正需要设计成接口，才选择接口