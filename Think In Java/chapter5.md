###chapter 5
####初始化与清理
####
+ 5.1用构造器确保初始化
+ 5.1.1方法重载
	* 重载存在与同一个类里面
	* 区分方法重载：通过独一无二的参数类型列表，参数顺序不同也足以区分两个方法（但不建议这样写代码，难以维护）
+ 5.1.2 基本类型参数的重载
	* 如果有某个重载方法接收传入类型参数，他就会被调用。如果传入的数据类型小于方法中声明的形式参数类型，实际数据类型就会被提升。
	* char 型不同，如果无法找到刚好接受char型参数的方法，就会把char直接提升至int型。
	* 如果传入的实际参数类型较大，就得通过强制类型转换来执行窄化转换，否则编译器会报错。
	* 根据方法返回值来区分重载方法不行，因为有时只是调用方法不管返回值如直接就是f()方法，就不知该调用哪个方法了
+ 5.2默认构造器
	* 如果已经定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器
+ 5.3this关键字
	* this关键字只能在方法内部使用
	* 在一个构造器中可以通过this(参数列表)调用另一个构造器，被调用构造器需要放在前面，否则编译器报错
	* 同时在一个构造器中最多只能调用一个构造器，不能调用两个或多个构造器
	* 在普通方法中不能通过this（参数列表）调用构造器
+ 5.4static关键字
	* 在static方法内部不能调用非静态方法，反过来可以，
	* 在static方法中不能使用this关键字，因为还没创建（存在）对象，是面向类
+ 5.5清理：终结处理和垃圾回收
	* 垃圾回收器只知道释放那些经由new分配的内存，并不知道如何释放并非使用new获取的'特殊'内存
	* 可以在类中定义一个finalize（）清理这些'特殊'内存
	* finalize()原理：一旦垃圾回收器准备好释放对象占用的存储空间，将会首先调用其finalize方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存
	* java对象并非总是被垃圾回收，所以并非一定会调用finalize方法
	* 有时会漏掉，因为垃圾回收本身也有开销。不调用就没开销
	* 如果java虚拟机（jvm）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存
	* System.gc()用于强制进行终结动作，显示调用垃圾回收器
+ 5.5.1 垃圾回收器如何工作
	* 垃圾回收器能明显的提高对象的创建速度
	* 垃圾回收器对对象重新排列，实现了一种高速的、有无限空间可供分配的堆模型
	* 停止--复制：暂停运行程序，将所有存活的对象从当前堆复制到另一个堆，没有被复制的全部是垃圾，当复制到新堆时，存活的对象在新堆中一个挨一个紧凑排列。
	* 标记--清扫：从堆栈和静态存储区出发遍历所有引用，标记所有存活对象，标记完多有存活对象后，对没有标记的对象进行清除，然后对凌乱无序的存活对象进行重新整理排列
+ 5.6.1成员初始化
	* java尽力保证，所有的变量在使用前都能得到恰当的初始化。对于方法的局部变量，java以编译时错误的形式来贯彻这种保证
	* 类的每个基本类型数据成员都会保证有一个初始值
+ 5.7.1 初始化顺序
	* 变量定义的先后顺序决定了初始化的顺序
	* 即使变量定义散布于方法定义之间（后面那些），他们仍旧会在任何方法（包括构造器）调用之前得到初始化
+ 5.7.2 静态数据初始化
	* 静态数据都只占用一份存储区域，static关键字不能作用于局部变量
	* 初始化的顺序是先静态，后非静态
	* 静态初始化只有在必要时刻才会进行，只有在第一个对象创建时或者第一次访问静态数据时才会初始化
+ 5.7.3 对象创建过程
	* 构造器也是static方法，静态方法或者静态域首次被访问时，java解释器必须查找类路径，定位.class文件
	* 载入.class文件创建一个Class对象，有关静态初始化的所有动作都会执行，
	* 即静态初始化只在Class对象首次加载时进行
	* 当用new关键字创建对象时，在堆上分配存储空间，这块存储空间会被清零，将对象的基本类型数据都设置成默认值。
+ 5.7.4 显示的静态初始化 
	* static静态代码块，仅执行一次，当首次生成这个类的一个对象时，或者首次访问属于这个类的静态数据成员时（即便从未生成过那个类的对象）
+ 5.7.5 数组初始化
	* 数组定义：类型名后加上一个空方括号，如int[] a 或者 int a[] 但是前一种定义更能表明是一个int型数组
	* 可以用花括号括起来的值来初始化数组{1,2,3}，但是它必须在创建数组的地方出现如 int[] a={1,2,3};
	* 初始化二
	 
			int[] a=new int[10]
			a[1]=10 
			或者
			int[] a;
			a=new int[10];
			a[1]=10;
			
	* 初始化三 
	
			int[] a=new int[]{1,2,3} 
			或
			int[] a;
			a=new int[]{1,2,3}
+ 5.8.1 可变参数列表
	* void method(Object... args) 参数被封装为一个数组
	* 方法调用method()/method(1,2,3)
	*同时存在几个可变参数列表方法，可能造成调用method()不知道该调用哪个方法。如void f(int... args)/void f(long... args),然后调用f()就不知该调用哪个方法，解决方法各自再添加一个不同类型的参数如void f(int a,int... args) void f(char c,long... args)
+ 5.9.1 枚举类型
	* enum关键字
	* 某个enum常量有ordinal（）方法获取在enum中声明顺序
	* static values()枚举类方法，以数组形式列出常量值
	* 枚举类的实例是常量，命名都用大写，如
	 
			public enum Spi{
				NOT,MILD,MEDIUM
			}
			Spi spi=Spi.MEDIUM;
	* enum看起来像是一种新的数据类型，但是enum关键字只是为enum生成对应的类时产生某些编译器行为，因此在很大程度上可以把enum当做其他任何类来处理，事实上enum确实是类
	